# Numpy用法

## 切片

```
import numpy as np

# 创建一个一维数组
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# 选择前5个元素
print(arr[:5])  # 输出: [1 2 3 4 5]

# 选择索引从3到7（不包括7）的元素
print(arr[3:7])  # 输出: [4 5 6 7]

# 选择从索引2开始，每隔一个元素取一个（步长为2）0print(arr[2::2])  # 输出: [3 5 7 9]

# 选择最后一个元素
print(arr[-1])  # 输出: 10

# 选择最后三个元素
print(arr[-3:])  # 输出: [8 9 10]



# 创建一个二维数组（矩阵）
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])

# 选择所有行和前两列
print(matrix[:, :2])
# 输出:
# [[ 1  2]
#  [ 4  5]
#  [ 7  8]
#  [10 11]]

# 选择前两行和所有列
print(matrix[:2, :])
# 输出:
# [[1 2 3]
#  [4 5 6]]

# 选择特定元素：第二行第二列的元素
print(matrix[1, 1])  # 输出: 5

# 选择第二行和第三行，以及第一列和第二列
print(matrix[1:3, :2])
# 输出:
# [[4 5]
#  [7 8]]

# 使用负数索引选择最后一行和最后一列
print(matrix[-1, -1])  # 输出: 12

# 选择除了最后一行以外的所有行和所有列
print(matrix[:-1, :])
# 输出:
# [[ 1  2  3]
#  [ 4  5  6]
#  [ 7  8  9]]




# 创建一个三维数组
arr_3d = np.arange(24).reshape(2, 3, 4)

# 选择第一个“层”的所有元素
print(arr_3d[0, :, :])
# 输出第一个二维数组层

# 选择第二个“层”的第二行和所有列
print(arr_3d[1, 1, :])
# 输出: [10 11 12 13]

# 使用省略号选择第二个“层”的第二行的所有元素
print(arr_3d[1, 1, ...])
# 这与上面的输出相同，因为在这个例子中省略号没有添加额外的维度选择

# 选择所有层的第二行的第二列元素
print(arr_3d[:, 1, 1])
# 输出: [ 6 14]

```

## shape

```
import numpy as np

# 创建一个二维NumPy数组
data = np.array([[1, 2, 3], [4, 5, 6]])
print(data.shape)  # 输出: (2, 3)，表示有2行3列
print(data.shape[0])  # 输出: 2，表示有2行

# 创建一个一维NumPy数组
data_1d = np.array([1, 2, 3, 4, 5])
print(data_1d.shape)  # 输出: (5,)，表示有5个元素
print(data_1d.shape[0])  # 输出: 5，表示有5个元素

# 创建一个三维NumPy数组
data_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(data_3d.shape)  # 输出: (2, 2, 2)，表示有2个深度为2x2的二维数组
print(data_3d.shape[0])  # 输出: 2，表示有2个这样的二维数组
```



## 最大值最小值

```
import numpy as np

# 创建一个二维NumPy数组
training_data = np.array([[1, 2, 3],
                          [4, 5, 1],
                          [7, 8, 2]])

# 计算沿着第一个轴（行方向）的最大值
max_values = training_data.max(axis=0)

print(max_values)  # 输出: [7 8 3]，这是每一列的最大值
```


## np.dot

```
np.dot 是 NumPy 库中的一个函数，用于执行两个数组的点积（dot product）或矩阵乘法。这个函数的行为取决于输入数组的形状（shape）。

基本用法

假设 A 和 B 是两个 NumPy 数组，np.dot(A, B) 的行为如下：

一维数组（向量）之间：如果 A 和 B 都是一维数组，那么 np.dot(A, B) 计算的是它们的点积，即对应元素相乘后求和的结果。

python
复制
import numpy as np
A = np.array([1, 2, 3])
B = np.array([4, 5, 6])
print(np.dot(A, B))  # 输出：32


二维数组（矩阵）与一维数组之间：如果 A 是二维数组（矩阵），B 是一维数组（向量），那么 np.dot(A, B) 执行的是矩阵与向量的乘法。

python
复制
A = np.array([[1, 2], [3, 4]])
B = np.array([5, 6])
print(np.dot(A, B))  # 输出：[17 39]


二维数组（矩阵）之间：如果 A 和 B 都是二维数组，那么 np.dot(A, B) 执行的是矩阵乘法，结果是一个新的二维数组。

python
复制
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
print(np.dot(A, B))
# 输出：
# [[19 22]
#  [43 50]]

注意事项
当处理二维数组时，确保第一个矩阵的列数（columns）与第二个矩阵的行数（rows）相匹配，这是矩阵乘法的一个基本要求。
np.dot 仅适用于二维数组和一维数组之间的操作。对于更高维度的数组，你可能需要使用 numpy.tensordot 或其他函数来执行更复杂的操作。
对于二维数组与二维数组之间的乘法，也可以使用 @ 运算符作为 np.dot 的简写，即 A @ B 等价于 np.dot(A, B)。

希望这能帮助你更好地理解 np.dot 的用法！
```

## training_data[:, :-1]  training_data[:, -1:]

```
这是一个二维数组，可以想象成一个表格，其中包含了多行（每个数据点或样本）和多列（每个样本的特征或属性）。
：,在第一个维度（行）上使用冒号表示选择该维度上的所有元素。也就是说，我们不过滤或选择特定的行，而是保留所有的行。
:-1,在第二个维度（列）上使用:-1表示选择从第一列开始到倒数第二列结束的所有列。这里的-1是一个索引，它指的是最后一个元素的前一个位置，即倒数第二个元素。因此，:-1排除了最后一列。
-1:,在第二个索引位置表示从最后一列开始，并且由于切片操作 [start:stop:step] 默认的 stop 是数组的末尾，并且这里我们没有指定 step（即步长为1），所以这个切片操作实际上就是从倒数第一列开始选择，直到数组的末尾。但由于我们明确指定了长度为1（通过 -1:），所以它只选择了最后一列。


import numpy as np  

# 假设 training_data 是一个二维数组  
training_data = np.array([  
    [1, 2, 3],  # 第一个样本的特征和目标变量  
    [4, 5, 6],  # 第二个样本的特征和目标变量  
    [7, 8, 9]   # 第三个样本的特征和目标变量  
])  

# 使用 training_data[:, -1:] 选择所有行的最后一列  
targets = training_data[:, -1:]  

# 输出 targets  
print(targets)  
# 输出:  
# [[3]  
#  [6]  
#  [9]]
```

## np.arange(-160.0, 160.0, 1.0)

```
np.arange(-160.0, 160.0, 1.0) 是一个使用 NumPy 库中的 arange 函数生成的数组。这个函数类似于 Python 内置的 range 函数，但它是为 NumPy 数组设计的，能够生成浮点数序列。
具体来说，np.arange(-160.0, 160.0, 1.0) 的意思是生成一个从 -160.0 开始（包括 -160.0），到 160.0 结束（不包括 160.0），步长为 1.0 的数组。
因此，这个调用会生成一个包含从 -160.0 到 159.0 的整数（以浮点数形式表示）的数组，总共有 320 个元素。
示例输出（部分展示）：
python复制代码array([-160., -159., -158., ...,  157.,  158.,  159.])
注意，这里的 ... 表示中间省略了很多元素，实际输出会包含从 -160.0 到 159.0 的所有整数（以浮点数形式）。
```

## np.zeros([len(w5), len(w9)])

```
np.zeros([len(w5), len(w9)]) 是一个使用 NumPy 库中的 zeros 函数生成数组的表达式，其中数组的形状由两个列表（或任何可迭代对象）w5 和 w9 的长度决定。具体来说，这个函数会创建一个二维数组，其行数等于 w5 的长度，列数等于 w9 的长度，数组中的所有元素都被初始化为 0。
这里，len(w5) 计算 w5 的长度（即其中元素的数量），而 len(w9) 计算 w9 的长度。这两个长度值作为 zeros 函数的 shape 参数，用于指定输出数组的形状。
假设 w5 是一个包含 5 个元素的列表，而 w9 是一个包含 9 个元素的列表，那么 np.zeros([len(w5), len(w9)]) 将生成一个 5x9 的二维数组，数组中的所有元素都是 0。
示例代码：
python复制代码import numpy as np    # 假设 w5 和 w9 是这样的列表  w5 = [1, 2, 3, 4, 5]  w9 = [10, 20, 30, 40, 50, 60, 70, 80, 90]    # 使用 np.zeros 生成一个 5x9 的二维数组，所有元素初始化为 0  arr = np.zeros([len(w5), len(w9)])    print(arr)  # 输出：  # [[0. 0. 0. 0. 0. 0. 0. 0. 0.]  #  [0. 0. 0. 0. 0. 0. 0. 0. 0.]  #  [0. 0. 0. 0. 0. 0. 0. 0. 0.]  #  [0. 0. 0. 0. 0. 0. 0. 0. 0.]  #  [0. 0. 0. 0. 0. 0. 0. 0. 0.]]
这个数组可以用于各种数值计算任务，比如作为初始化矩阵、存储计算结果等。
```

## 数组示例

```
# 创建一个二维数组（实际上是列表的列表）  
two_d_array = [  
    [1, 2, 3],  
    [4, 5, 6],  
    [7, 8, 9]  
]  

# 访问二维数组的元素  
print(two_d_array[1][2])  # 输出: 6

-------

# 创建一个三维数组（实际上是列表的列表的列表）  
three_d_array = [  
    [  
        [1, 2, 3],  
        [4, 5, 6]  
    ],  
    [  
        [7, 8, 9],  
        [10, 11, 12]  
    ]  
]  

# 访问三维数组的元素  
print(three_d_array[1][0][2])  # 输出: 9

-------

import numpy as np  

# 创建一个二维数组  
two_d_array = np.array([  
    [1, 2, 3],  
    [4, 5, 6],  
    [7, 8, 9]  
])  

# 访问二维数组的元素  
print(two_d_array[1, 2])  # 使用逗号分隔索引以访问二维数组的元素，输出: 6

-------

import numpy as np  

# 创建一个三维数组  
three_d_array = np.array([  
    [  
        [1, 2, 3],  
        [4, 5, 6]  
    ],  
    [  
        [7, 8, 9],  
        [10, 11, 12]  
    ]  
])  

# 注意：上面的three_d_array实际上是一个二维数组，其中每个元素是一个列表。  
# 要创建真正的三维NumPy数组，应该确保所有内部元素都是相同维度的数组。  
# 下面是一个真正的三维NumPy数组示例  
three_d_array_np = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])  

# 访问三维数组的元素  
print(three_d_array_np[1, 0, 2])  # 输出: 9
```


## np.mean计算平均值

```
np.mean 是 NumPy 库中用于计算数组平均值的函数。这个函数非常强大且灵活，可以处理一维或多维数组，并允许你指定沿着哪个轴（如果有的话）来计算平均值。
基本用法
import numpy as np  

# 创建一个一维数组  
arr_1d = np.array([1, 2, 3, 4, 5])  

# 计算整个数组的平均值  
mean_value = np.mean(arr_1d)  
print(mean_value)  # 输出: 3.0  

# 创建一个二维数组  
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])  

# 计算整个二维数组的平均值（不考虑轴）  
mean_2d_all = np.mean(arr_2d)  
print(mean_2d_all)  # 输出: 3.5  

# 沿着轴 0（列）计算平均值  
mean_2d_axis0 = np.mean(arr_2d, axis=0)  
print(mean_2d_axis0)  # 输出: [2.5 3.5 4.5]  

# 沿着轴 1（行）计算平均值  
mean_2d_axis1 = np.mean(arr_2d, axis=1)  
print(mean_2d_axis1)  # 输出: [2. 5.]

参数
a（array_like）：输入数组，可以是数组、列表（或其他可迭代对象，它们将被转换为数组）。
axis（None 或 int 或 tuple of ints，可选）：指定要计算平均值的轴。如果为 None，则计算整个数组的平均值；如果为整数，则计算指定轴上的平均值；如果为整数元组，则计算多个轴上的平均值。
dtype（dtype，可选）：指定返回值的类型。如果未指定，则返回值的类型将与输入数组的类型相同（或更高精度）。
out（ndarray，可选）：一个数组，用于放置输出。这可以避免额外的内存分配。
keepdims（bool，可选）：如果为 True，则输出的数组将保持输入数组的维度。默认情况下，keepdims=False，输出数组的维度会比输入数组少一维。
where（array_like of bool，可选）：一个条件表达式，用于指定哪些元素应该被包含在计算中。
注意事项
当 np.mean 应用于空切片时，它会返回 NaN（不是数字）。
如果 dtype 参数被指定为整数类型，并且结果需要小数部分，则结果将被截断为最接近的整数。为了避免这种情况，最好让 np.mean 自动选择数据类型，或者显式地指定一个浮点类型作为 dtype。
使用 where 参数可以方便地计算满足特定条件的元素的平均值。
np.mean 是 NumPy 库中非常基础且常用的函数之一，它在数据分析、科学计算和机器学习等领域都有广泛的应用。
```
